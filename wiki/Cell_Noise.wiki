#summary Explanation of Cell Noise.

= Introduction =
Cell Noise, also called Worley Noise, is a very simple yet fascinating algorithm. It ends up being slower than Perlin_Noise, but is still relatively fast. The quality is not compatible with our current algorithms, however it creates fascinating patterns that can be used for certain landscapes

= Contents =
<wiki:toc max_depth="3" />


= Algorithm = 
Cell Noise is a very simple algorithm, but can yield incredible results. The algorithm only has two parts:

  # Set up an array of points around the image
  # For any pixel, the value is the distance from the n^th^ closest point.

This is relatively simple, but the simplicity allows for a lot of experimentation. A few things can be mixed up.

  * The distance function
  * Which point to use for the distance function
  * How to combine the above two

First, there are many different distance functions that can be used. First and easiest to grasp is the *Euclidean* function:

{{{
    x_difference = pixel.x - closest_point.x;
    y_difference = pixel.y - closest_point.y;

    distance = sqrt(x_difference * x_difference + y_difference * y_difference);
}}}

This is just the Pythagorean Theorem: a^2^ + b^2^ = c^2^. A variation on this is *Euclidean-Squared*, which is the same but leaves off the square-root function, as this is computationally very slow. This creates steeper slopes, but still gives roughly the same image at a better speed.

Next is the *Manhattan* function, also called the City Block function:

{{{
    x_difference = pixel.x - closest_point.x;
    y_difference = pixel.y - closest_point.y;

    distance = abs(x_difference) + abs(y_difference);
}}}

This creates diamond-shaped patterns that don't make very good terrains, but are still interesting. There are many less common functions (a couple of which are in the source code), and anyone can create their own distance function.

Next we can vary which point is chosen. Most often it is the closest, but it can also be the second-closest, or third-closest, or even 15th-closest. This is denoted by an F and then the number. So using the first-closest point is denoted by F1, the second-closest point is denoted by F2, the 15th-closest point is denoted by F15, and so on. Depending on the distance function, the output can change dramatically between choices.

Finally, we can combine these in interesting ways. For example, deciding a point based on Euclidean F2-F1 (the output of the second-closest point minus the output of the closest point distance functions) produces very crisp lines, as can be seen below. There are no bounds on the combinations; it is even possible to use cell noise values as seeds in other algorithms, or in cell noise itself. There are infinite possibilities, but most don't look very good. Here are some of the more common approaches:

= Gallery =
Euclidean F1:

http://gimli.morningside.edu/~tra001/Algorithms/CellNoise/F1.png

Euclidean F2:

http://gimli.morningside.edu/~tra001/Algorithms/CellNoise/F2.png

Euclidean F2 - F1:

http://gimli.morningside.edu/~tra001/Algorithms/CellNoise/F2-F1.png

Euclidean F1 + F2:

http://gimli.morningside.edu/~tra001/Algorithms/CellNoise/F1+F2.png

Euclidean F1 - F2:

http://gimli.morningside.edu/~tra001/Algorithms/CellNoise/F1-F2.png

Euclidean F1 `*` F2:

http://gimli.morningside.edu/~tra001/Algorithms/CellNoise/F1.F2.png

Euclidean F1 with Fractional_Brownian_Motion in black and white:

http://gimli.morningside.edu/~tra001/Algorithms/CellNoise/blacknwhitefbm.png

Euclidean F1 with Fractional_Brownian_Motion colorized:

http://gimli.morningside.edu/~tra001/Algorithms/CellNoise/colorfbm.png

Manhattan F1:

http://gimli.morningside.edu/~tra001/Algorithms/CellNoise/manhattanF1.png

Manhattan F2:

http://gimli.morningside.edu/~tra001/Algorithms/CellNoise/manhattanF2.png


= Comparison =

== Pros ==
  * Pretty Fast
  * Fascinating output
  * Highly customizable
  * Easy to understand and easy to implement

== Cons ==
  * Slower than Perlin_Noise and Simplex_Noise
  * Doesn't look as random as the other algorithms: there are definitive shapes

= Ideas =
Because it is so easy to customize this algorithm and it has reasonably fast output, I'd like to create a genetic algorithm that would learn to create more interesting images. The color gradient, distance function, point-selection, and combinations could all be altered with fascinating results. The fitness function would either be human-based (which would be very slow) or I'll have to come up with something clever to objectively grade how interesting an image is.

= Conclusions =
In the other algorithms, output has been relatively featureless: it always looked like a wavy sheet, which when combined with Fractional_Brownian_Motion creates terrain-like fractals. With Cell Noise there are always definitive shapes and lines, which doesn't appear to create very convincing terrain. In the above colored Euclidean F1 with fBm, it looks very rounded and hilly. On the other hand, output like Euclidean F2 or Euclidean F2-F1 looks a lot like a system of canyons. While it doesn't fit with my current look, I will definitely be saving it for other types of terrain and for purely artistic images. In all, a simple yet fascinating algorithm.

Click here to see it in action:
http://gimli.morningside.edu/~tra001/Algorithms/CellNoise/CellNoise.cgi